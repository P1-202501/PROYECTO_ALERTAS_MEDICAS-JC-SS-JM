    import smtplib
    import logging #M√≥dulo para registrar eventos o errores en un archivo de log
    from email.mime.text import MIMEText

    # Configuraci√≥n del sistema de logs
    logging.basicConfig(
        filename="monitoreo_signos.log", #Define el nombre del archivo donde se guardar√°n los logs
        level=logging.DEBUG, 
        format="%(asctime)s - %(levelname)s - %(message)s", #Define c√≥mo se ver√° cada mensaje en el log. Por ejemplo, en el log veremos la fecha, el nivel del evento (como "DEBUG" o "ERROR") y el mensaje que hemos escrito.
        datefmt="%Y-%m-%d %H:%M:%S" #formato de fecha y hora que queremos para los logs
    )

    # Configuraci√≥n del servidor SMTP
    SMTP_SERVER = "smtp.gmail.com"
    SMTP_PORT = 465  # Conexi√≥n segura SSL
    EMAIL_USER = "jezucarrillo120@gmail.com"
    EMAIL_PASSWORD = "ebrgvopmssjgwmsl"  # Usa una contrase√±a de aplicaci√≥n segura

    # Lista de destinatarios
    destinatarios = ["CARRILLO.JESUS@UCES.EDU.CO", "sanchezs.sara@uces.edu.co"]

    # Funci√≥n para enviar alertas m√©dicas por correo
    def enviar_alerta(alertas):
        """Env√≠a un correo con las alertas m√©dicas generadas"""
        if not alertas:
            return  # No hay alertas, no se env√≠a correo
        
        mensaje_texto = "\n".join(alertas)  # Unir alertas en un solo mensaje
        mensaje = MIMEText(mensaje_texto)   #creaar el mensaje de correo en formato de texto
        mensaje["Subject"] = "üö® Alerta M√©dica - Signos Vitales Fuera de Rango"
        mensaje["From"] = EMAIL_USER
        mensaje["To"] = ", ".join(destinatarios)

        try:
            print("üì© Enviando alerta m√©dica...")
            conexion = smtplib.SMTP_SSL(SMTP_SERVER, SMTP_PORT) # Conectar al servidor SMTP con SSL
            conexion.login(EMAIL_USER, EMAIL_PASSWORD)
            conexion.sendmail(EMAIL_USER, destinatarios, mensaje.as_string())
            conexion.quit()
            print("‚úÖ Alerta m√©dica enviada correctamente")
        except Exception as e:
            print(f"‚ùå Error al enviar el correo: {e}")
            logging.error(f"Error al enviar el correo: {e}") # Registrar el error en los logs

    # Funci√≥n para evaluar si un signo vital est√° fuera de los rangos normales
    def evaluar_signo_vital(tipo, valor):
        """Eval√∫a signos vitales y genera alertas m√©dicas"""
        limites = {
            'frecuencia_cardiaca': (60, 100),
            'presion_arterial': ((90, 120), (60, 80)), # Aqu√≠ hay dos tuplas, una para sist√≥lica y otra para diast√≥lica
            'temperatura': (36.0, 37.5),
            'frecuencia_respiratoria': (12, 20)
        }
        recomendaciones = {
            'frecuencia_cardiaca': "Si su frecuencia card√≠aca es anormal, consulte a un m√©dico.",
            'presion_arterial': "Si su presi√≥n arterial est√° fuera de los rangos normales, consulte a un especialista.",
            'temperatura': "Si tiene fiebre o temperatura baja, consulte a un m√©dico.",
            'frecuencia_respiratoria': "Si su respiraci√≥n es irregular, busque atenci√≥n m√©dica si persiste."
        }

        if tipo == 'presion_arterial':
            sistolica, diastolica = valor
            normal_sistolica = limites[tipo][0][0] <= sistolica <= limites[tipo][0][1] #limites[tipo][0]: Accede al primer elemento de la tupla de valores para ese signo vital
            normal_diastolica = limites[tipo][1][0] <= diastolica <= limites[tipo][1][1] #limites[tipo][0][1]: Accede al segundo valor de la tupla
            normal = normal_sistolica and normal_diastolica 
        else:
            normal = limites[tipo][0] <= valor <= limites[tipo][1] 

        estado = "Normal" if normal else " Anomal√≠a"
        recomendacion = recomendaciones[tipo] if not normal else "Todo est√° bien." 
        # Registrar en los logs el estado y recomendaci√≥n para cada signo vital
        logging.info(f"{tipo.replace('_', ' ').capitalize()} - Estado: {estado}, Recomendaci√≥n: {recomendacion}")

        return estado, recomendacion

    # Funci√≥n para solicitar y validar el valor de los signos vitales
    def obtener_signo_vital(tipo):
        """Solicita y valida los valores de los signos vitales"""
        while True:
            valor = input(f"Ingrese el valor de {tipo.replace('_', ' ')}: ")

            if tipo == 'presion_arterial':
                valores = valor.split("/")  # Permitir ingreso en formato "120/80"
                if len(valores) == 2 and all(v.isdigit() for v in valores): #len(valores) devuelve la cantidad de elementos en la lista valores
                    valor = (int(valores[0]), int(valores[1]))              #all(v.isdigit() for v in valores) verifica que todos los elementos de la lista valores sean cadenas de texto que representen n√∫meros enteros.
                    return valor
                else:
                    print("‚ö†Ô∏è Error: Ingrese la presi√≥n en formato '120/80'. Intente de nuevo.")
            else:
                try:
                    valor = float(valor)
                    if valor <= 0:
                        print(f"‚ö†Ô∏è Error: El valor de {tipo.replace('_', ' ')} debe ser un n√∫mero positivo. Intente de nuevo.") 
                    else:
                        return valor                   #El tipo.replace('_', ' ') se usa para formatear el nombre del signo vital (por ejemplo, "frecuencia_cardiaca" se convierte en "frecuencia cardiaca" para que sea m√°s legible
                except ValueError:
                    print(f"‚ö†Ô∏è Error: El valor de {tipo.replace('_', ' ')} debe ser un n√∫mero v√°lido. Intente de nuevo.")

    # Funci√≥n principal para monitorear signos vitales
    def monitorear_signos():
        """Solicita y eval√∫a la entrada de signos vitales del usuario y env√≠a alertas si es necesario"""
        signos = ['frecuencia_cardiaca', 'presion_arterial', 'temperatura', 'frecuencia_respiratoria']
        datos_paciente = {} 
        alertas = []

        print("\n--- MONITOREO DE SIGNOS VITALES ---\n")
        logging.info("Inicio del monitoreo de signos vitales.")

        for signo in signos:
            valor = obtener_signo_vital(signo)  # Obtener y validar el valor del signo vital
            datos_paciente[signo] = valor
            estado, recomendacion = evaluar_signo_vital(signo, valor)  # Evaluar datos
            
            print(f"\n{signo.replace('_', ' ').capitalize()}: {valor} -> Estado: {estado}")
            print(f"Recomendaci√≥n: {recomendacion}\n")

            # Si el signo est√° fuera de rango, agregar alerta para enviar
            if estado == "‚ö†Ô∏è Anomal√≠a":
                alertas.append(f"üî¥ {signo.replace('_', ' ').capitalize()}: {valor} - {recomendacion}") #capitalize() asegura que la primera letra de cada palabra est√© en may√∫scula

        logging.info("Finalizaci√≥n del monitoreo de signos vitales.")

        # Si hay alertas, enviar correo
        if alertas:
            enviar_alerta(alertas)

        return datos_paciente

    # Punto de entrada principal del programa
    if __name__ == "__main__":
        datos = monitorear_signos()